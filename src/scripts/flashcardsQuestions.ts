import pool from "../util/db";
import axios, { CanceledError } from "axios";
import getTTSParams from "../util/getTTSParams";
import { IFlashcardsQueryRes } from "../interfaces/IFlashcardsQueryRes";
import sleep from "../util/sleep";
import { uploadFile, deleteFile } from "../util/s3";

const ELEVENLABS_API_KEY = process.env.ELEVENLABS_API_KEY!;
const ELEVENLABS_API_URL = "https://api.elevenlabs.io/v1/text-to-speech";
const CHUNK_SIZE = 2;
const MAX_RETRIES = 5;
const BATCH_DELAY = 10000;

if (!ELEVENLABS_API_KEY) {
    throw new Error("‚ùå ELEVENLABS_API_KEY is not set in the environment variables.");
}

async function processFlashcard(
    flashcard: IFlashcardsQueryRes,
    index: number,
    dbClient = pool,
    s3Upload = uploadFile,
    s3Delete = deleteFile
): Promise<IFlashcardsQueryRes | null> {
    let client;
    try {
        client = await dbClient.connect();
        console.log(`üîµ D√©but de la transaction pour la question ${flashcard.questionid}.`);
        await client.query('BEGIN');

        if (!flashcard.question || flashcard.question.trim() === "") {
            console.warn(`‚ö†Ô∏è Question vide pour l'ID : ${flashcard.questionid}`);
            await client.query('ROLLBACK');
            console.log("üîô Transaction annul√©e (ROLLBACK) : Question vide.");
            return null;
        }

        const sanitizedQuestion = flashcard.question.replace(/[^a-zA-Z√Ä-√ñ√ò-√∂√∏-√øÿ°-Ÿä0-9 ?!.,+\-*/=()^%<>$‚Ç¨'"‚Äô]/gu, '') ; // Garde les apostrophes
        if (sanitizedQuestion.length === 0) {
            console.warn(`‚ö†Ô∏è Question invalide d√©tect√©e pour l'ID : ${flashcard.questionid}`);
            await client.query('ROLLBACK');
            console.log("üîô Transaction annul√©e (ROLLBACK) : Question invalide.");
            return null;
        }

        console.log(`‚è≥ Traitement de la question ${flashcard.questionid}...`);
        await sleep(index * 100);

        const params = getTTSParams(flashcard.language, sanitizedQuestion);
        console.log(`üéôÔ∏è Envoi √† ElevenLabs: ${sanitizedQuestion}`);

        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 60000);

        for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
            try {
                console.log("üéôÔ∏è Envoi √† ElevenLabs...");
                const response = await axios.post(
                    `${ELEVENLABS_API_URL}/${params.voice_id}`,
                    {
                        text: params.text,
                        model_id: params.model_id,
                        voice_settings: params.voice_settings,
                    },
                    {
                        headers: {
                            "xi-api-key": ELEVENLABS_API_KEY,
                            "Content-Type": "application/json",
                        },
                        responseType: "arraybuffer",
                        signal: controller.signal,
                    }
                );

                clearTimeout(timeout);
                console.log("‚úÖ R√©ponse re√ßue de ElevenLabs.");

                const audioBuffer = Buffer.from(response.data, "binary");
                if (!audioBuffer || audioBuffer.length === 0) {
                    throw new Error("‚ùå Aucune donn√©e audio re√ßue de l'API ElevenLabs.");
                }
                console.log(`üéµ Taille du fichier audio : ${audioBuffer.length} bytes`);

                const s3Key = `audios-bewize/flashcards/questions/${flashcard.questionid}.mp3`;

                console.log(`üìù Mise √† jour initiale de la base de donn√©es pour l'ID : ${flashcard.questionid}`);
                const tempRes = await client.query(
                    "UPDATE question SET question_audio = 'PROCESSING' WHERE id = $1 RETURNING id",
                    [flashcard.questionid]
                );

                if (tempRes.rowCount === 0) {
                    throw new Error(`‚ùå Initial SQL update failed for ID: ${flashcard.questionid}`);
                }

                try {
                    console.log("üì§ Tentative d'upload sur S3...");
                    await s3Upload(s3Key, audioBuffer, "audio/mpeg");

                    console.log(`‚úÖ Upload sur S3 r√©ussi : ${s3Key}`);
                } catch (s3Error) {
                    console.error(`‚ùå Erreur pendant l'upload sur S3: ${s3Error.message}`);
                    await client.query('ROLLBACK');
                    console.log("üîô Transaction annul√©e (ROLLBACK) : √âchec de l'upload sur S3.");
                    throw new Error(`S3 upload failed for ${flashcard.questionid}`);
                }

                try {
                    console.log("üìù Tentative de mise √† jour de la base de donn√©es...");
                    const updateRes = await client.query(
                        "UPDATE question SET question_audio = $1 WHERE id = $2 RETURNING id",
                        [s3Key, flashcard.questionid]
                    );

                    console.log("üìù R√©sultat de la mise √† jour :", updateRes.rowCount);

                    if (updateRes.rowCount === 0) {
                        throw new Error(`Final SQL update failed for ID: ${flashcard.questionid}`);
                    }

                    await client.query('COMMIT');
                    console.log("‚úÖ Transaction valid√©e (COMMIT).");
                    console.log(`‚úÖ Base de donn√©es mise √† jour pour ${flashcard.questionid}`);
                    flashcard.question_audio = s3Key;
                    return flashcard;
                } catch (sqlError) {
                    console.error(`‚ùå Erreur pendant la mise √† jour SQL : ${sqlError.message}`);
                    await client.query('ROLLBACK');
                    console.log("üîô Transaction annul√©e (ROLLBACK) : √âchec de la mise √† jour SQL.");

                    try {
                        await client.query(
                            "UPDATE question SET question_audio = NULL WHERE id = $1",
                            [flashcard.questionid]
                        );
                        console.log("üîÑ question_audio r√©initialis√© √† NULL apr√®s √©chec SQL.");
                    } catch (resetError) {
                        console.error(`‚ùå Erreur lors de la r√©initialisation de question_audio : ${resetError.message}`);
                        throw new Error(`Failed to reset question_audio: ${resetError.message}`);
                    }

                    try {
                        console.log(`üóëÔ∏è Suppression du fichier S3 : ${s3Key}`);
                        await s3Delete(s3Key);
                        console.log(`‚úÖ Fichier S3 supprim√© apr√®s √©chec SQL.`);
                    } catch (deleteError) {
                        console.error(`‚ùå Erreur lors de la suppression du fichier S3 (${s3Key}) : ${deleteError.message}`);
                    }
                    throw new Error(`Final SQL update failed for ID: ${flashcard.questionid}`);
                }
            } catch (error) {
                if (error instanceof CanceledError) {
                    console.error("‚ùå La requ√™te a √©t√© annul√©e.");
                    throw error;
                } else if (error.response && error.response.status === 401) {
                    console.error("‚ùå Unauthorized error: Please check your ELEVENLABS_API_KEY.");
                    throw error;
                } else if (error.response && error.response.status === 404) {
                    console.error("‚ùå Not Found error: Invalid request.");
                    throw error;
                } else if (error.response && error.response.status === 429) {
                    console.error("‚ùå Too Many Requests: Rate limit exceeded.");
                    throw error;
                } else if (error.response && error.response.status === 500) {
                    console.error("‚ùå Internal Server Error: Please try again later.");
                    throw error;
                } else {
                    clearTimeout(timeout);
                    await client.query('ROLLBACK');
                    console.log("üîô Transaction annul√©e (ROLLBACK) : Erreur pendant le traitement.");
                    console.error(`‚ùå Erreur pendant le traitement : ${error.message}`);
                    throw error;
                }
            }
        }
        return null;
    } catch (error) {
        await client?.query('ROLLBACK');
        console.log("üîô Transaction annul√©e (ROLLBACK) : Erreur pendant le traitement.");
        console.error(`‚ùå Erreur pendant le traitement : ${error.message}`);
        throw error;
    } finally {
        if (client) {
            client.release();
        }
    }
}

export const flashcardsQuestions = async (level: string, subject?: string) => {
    console.log(`üîç Ex√©cution pour le niveau : ${level}${subject ? ` et la mati√®re : ${subject}` : ''}`);

    let query = `
        SELECT que.id AS questionid, s.title AS language, que.question
        FROM subject s
        JOIN course c ON s.id = c.subject_id
        JOIN level l ON l.id = c.level_id
        JOIN quiz qui ON c.id = qui.course_id
        JOIN question que ON qui.id = que.quiz_id
        WHERE l.level_name = $1
        AND qui.type = 'FLASHCARD'
        AND (que.question_audio IS NULL OR TRIM(que.question_audio) = '')`;

    const queryParams: any[] = [level];

    if (subject) {
        query += ` AND s.title = $2`;
        queryParams.push(subject);
    }

    try {
        console.log("‚ö° Ex√©cution de la requ√™te SQL...");
        const result = await pool.query(query, queryParams);
        const flashcards = <IFlashcardsQueryRes[]>result.rows;

        if (flashcards.length === 0) {
            console.log("‚úÖ Aucun flashcard trouv√© pour ces crit√®res.");
            return [];
        }

        console.log(`üîç Trouv√© ${flashcards.length} questions sans audio.`);

        const results = [];
        for (let i = 0; i < flashcards.length; i += CHUNK_SIZE) {
            const batch = flashcards.slice(i, i + CHUNK_SIZE);
            const batchResults = await Promise.all(batch.map((flashcard, index) => processFlashcard(flashcard, index)));
            results.push(...batchResults.filter(result => result !== null));

            console.log(`‚åõ Waiting for ${BATCH_DELAY / 1000} seconds before processing the next batch...`);
            await sleep(BATCH_DELAY);
        }

        console.log("üéâ Traitement termin√© !");
        return results;
    } catch (error) {
        if (error.message.includes('Database connection failed')) {
            console.error("‚ùå Database connection failed:", error.message);
            throw new Error("Database connection failed");
        } else {
            console.error("‚ùå Error:", error.message);
            throw error;
        }
    }
};

export default flashcardsQuestions;